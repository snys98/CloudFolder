# The `@defer` directive may be provided for fragment spreads and inline fragments
# to inform the executor to delay the execution of the current fragment to
# indicate deprioritization of the current fragment. A query with `@defer`
# directive will cause the request to potentially return multiple responses, where
# non-deferred data is delivered in the initial response and data deferred is
# delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`.
directive @defer(
  # If this argument label has a value other than null, it will be passed on to
  # the result of this defer directive. This label is intended to give client
  # applications a way to identify to which fragment a deferred result belongs to.
  label: String
  # Deferred when true.
  if: Boolean
) on FRAGMENT_SPREAD | INLINE_FRAGMENT
# The `@stream` directive may be provided for a field of `List` type so that the
# backend can leverage technology such as asynchronous iterators to provide a
# partial list in the initial response, and additional list items in subsequent
# responses. `@include` and `@skip` take precedence over `@stream`.
directive @stream(
  # If this argument label has a value other than null, it will be passed on to
  # the result of this stream directive. This label is intended to give client
  # applications a way to identify to which fragment a streamed result belongs to.
  label: String
  # The initial elements that shall be send down to the consumer.
  initialCount: Int!
  # Streamed when true.
  if: Boolean!
) on FIELD
directive @authorize(
  # The name of the authorization policy that determines access to the annotated resource.
  policy: String
  # Roles that are allowed to access the annotated resource.
  roles: [String!]
  # Defines when when the resolver shall be executed.By default the resolver is
  # executed after the policy has determined that the current user is allowed to
  # access the field.
  apply: ApplyPolicy! = BEFORE_RESOLVER
) on SCHEMA | OBJECT | FIELD_DEFINITION
directive @first(count: Int = 1) on FIELD
directive @last(count: Int = 1) on FIELD
# The `@specifiedBy` directive is used within the type system definition language
# to provide a URL for specifying the behavior of custom scalar definitions
# .
directive @specifiedBy(
  # The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types
    # .
  url: String!
) on SCALAR
scalar Any

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
}

# ^\[1\]\(\[3-9\]\)[0-9]{9}
# $
scalar ChinesePhoneNumberType

# Information about the offset pagination.
type CollectionSegmentInfo {
  # Indicates whether more items exist following the set defined by the clients arguments.
  hasNextPage: Boolean!
  # Indicates whether more items exist prior the set defined by the clients arguments.
  hasPreviousPage: Boolean!
}

enum CompaniesSettings {
  COMPANIES_USER_MAPPING
}

input ComparableDateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime!]
  nin: [DateTime!]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input CreateCompanyRequestInput {
  code: String
  name: String
}

input CreateMessageRequestInput {
  text: String!
  severity: MessageSeverityType!
}

# The `DateTime` scalar represents
# an ISO-8601 compliant date time type.
scalar DateTime

input DeleteCompanyRequestInput {
  ids: [String]
}

input DeleteMessageDistributionsInput {
  messageId: String!
  userIds: [String!]!
}

input EditCompanyRequestInput {
  id: String
  name: String
}

input EditMessageRequestInput {
  text: String
  severity: MessageSeverityType
  id: String!
  messageType: MessageType
}

type ExternalCompany {
  name: String
  code: String
}

enum FrontendCallType {
  NEW_MESSAGE
}

enum GeexClaimType {
  AVATAR
  EXPIRES
  NICKNAME
  PROVIDER
  SUB
}

enum GeexExceptionType {
  CONFLICT
  NOT_FOUND
  ON_PURPOSE
  UNKNOWN
  VALIDATION_FAILED
}

input GetSettingsInput {
  scope: SettingScopeEnumeration
}

input GetUnreadMessagesInput {
  _: String!
}

type ICompany {
  name: String
  code: String
}

type ICompanyCollectionSegment {
  items: [ICompany]
  # Information to aid in pagination.
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ICompanyFilterInput {
  and: [ICompanyFilterInput!]
  or: [ICompanyFilterInput!]
  name: StringOperationFilterInput
  code: StringOperationFilterInput
}

type IFrontendCall {
  data: Any
  frontendCallType: FrontendCallType!
}

type IMessage {
  fromUserId: String
  messageType: MessageType!
  content: IMessageContent!
  toUserIds: [String!]!
  id: String!
  severity: MessageSeverityType!
  title: String!
  time: DateTime!
}

type IMessageCollectionSegment {
  items: [IMessage]
  # Information to aid in pagination.
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type IMessageContent {
  _: String!
}

input IMessageContentFilterInput {
  and: [IMessageContentFilterInput!]
  or: [IMessageContentFilterInput!]
  _: StringOperationFilterInput
}

input IMessageFilterInput {
  and: [IMessageFilterInput!]
  or: [IMessageFilterInput!]
  messageType: MessageTypeOperationFilterInput
  id: StringOperationFilterInput
  fromUserId: StringOperationFilterInput
  content: IMessageContentFilterInput
  toUserIds: ListStringOperationFilterInput
  severity: MessageSeverityTypeOperationFilterInput
  title: StringOperationFilterInput
  time: ComparableDateTimeOperationFilterInput
}

type ISetting {
  scope: SettingScopeEnumeration
  scopedKey: String
  value: String
  name: SettingDefinition
  id: String
}

type KeyValuePairOfStringAndObject {
  key: String!
}

input ListStringOperationFilterInput {
  all: StringOperationFilterInput
  none: StringOperationFilterInput
  some: StringOperationFilterInput
  any: Boolean
}

input MarkMessagesReadInput {
  messageIds: [String!]!
  userId: String!
}

enum MessageSeverityType {
  INFO
  SUCCESS
  WARN
  ERROR
  FATAL
}

input MessageSeverityTypeOperationFilterInput {
  eq: MessageSeverityType
  neq: MessageSeverityType
  in: [MessageSeverityType!]
  nin: [MessageSeverityType!]
}

enum MessageType {
  NOTIFICATION
  TODO
  INTERACT
}

input MessageTypeOperationFilterInput {
  eq: MessageType
  neq: MessageType
  in: [MessageType!]
  nin: [MessageType!]
}

enum MessagingSettings {
  COMPANIES_USER_MAPPING
}

type Mutation {
  markMessagesRead(input: MarkMessagesReadInput!): Boolean!
  deleteMessageDistributions(input: DeleteMessageDistributionsInput!): Boolean!
  sendMessage(input: SendNotificationMessageRequestInput!): Boolean!
  createMessage(input: CreateMessageRequestInput!): IMessage!
  editMessage(input: EditMessageRequestInput!): Boolean!
  contextData: [KeyValuePairOfStringAndObject!]!
  scope: String
  name: Name!
  description: String
  updateSetting(input: UpdateSettingInput): ISetting
  submitCompany(id: String): Boolean
  auditCompany(id: String): Boolean
  createCompany(input: CreateCompanyRequestInput): ICompany
  editCompany(input: EditCompanyRequestInput): Boolean!
  deleteCompany(input: DeleteCompanyRequestInput): Boolean!
}

# The name scalar represents
# a valid GraphQL name as specified in the spec and can be used to refer to fields or types.
scalar Name

scalar ObjectId

type Query {
  messages(
    skip: Int
    take: Int
    where: IMessageFilterInput
  ): IMessageCollectionSegment
  unreadMessages(input: GetUnreadMessagesInput!): [IMessage!]!
  contextData: [KeyValuePairOfStringAndObject!]!
  scope: String
  name: Name!
  description: String
  settings(input: GetSettingsInput): [ISetting]
  companies(
    skip: Int
    take: Int
    where: ICompanyFilterInput
  ): ICompanyCollectionSegment
  externalCompanies: [ExternalCompany]
}

input SendNotificationMessageRequestInput {
  toUserIds: [String!]!
  messageId: String!
}

enum SettingDefinition {
  COMPANIES_USER_MAPPING
}

enum SettingScopeEnumeration {
  GLOBAL
  USER
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

type Subscription {
  onFrontendCall: IFrontendCall!
  contextData: [KeyValuePairOfStringAndObject!]!
  scope: String
  name: Name!
  description: String
}

input UpdateSettingInput {
  name: SettingDefinition
  value: String
  scopedKey: String
  scope: SettingScopeEnumeration
}

