# The `@defer` directive may be provided for fragment spreads and inline fragments
# to inform the executor to delay the execution of the current fragment to
# indicate deprioritization of the current fragment. A query with `@defer`
# directive will cause the request to potentially return multiple responses, where
# non-deferred data is delivered in the initial response and data deferred is
# delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`.
directive @defer(
  # If this argument label has a value other than null, it will be passed on to
  # the result of this defer directive. This label is intended to give client
  # applications a way to identify to which fragment a deferred result belongs to.
  label: String
  # Deferred when true.
  if: Boolean
) on FRAGMENT_SPREAD | INLINE_FRAGMENT
# The `@stream` directive may be provided for a field of `List` type so that the
# backend can leverage technology such as asynchronous iterators to provide a
# partial list in the initial response, and additional list items in subsequent
# responses. `@include` and `@skip` take precedence over `@stream`.
directive @stream(
  # If this argument label has a value other than null, it will be passed on to
  # the result of this stream directive. This label is intended to give client
  # applications a way to identify to which fragment a streamed result belongs to.
  label: String
  # The initial elements that shall be send down to the consumer.
  initialCount: Int!
  # Streamed when true.
  if: Boolean!
) on FIELD
directive @first(count: Int = 1) on FIELD
directive @last(count: Int = 1) on FIELD
# ^\[1\]\(\[3-9\]\)[0-9]{9}$
scalar ChinesePhoneNumberType

# Information about the offset pagination.
type CollectionSegmentInfo {
  # Indicates whether more items exist following the set defined by the clients arguments.
  hasNextPage: Boolean!
  # Indicates whether more items exist prior the set defined by the clients arguments.
  hasPreviousPage: Boolean!
}

enum CompaniesSettings {
  COMPANIES_USER_MAPPING
}

input CreateCompanyRequestInput {
  code: String
  name: String
}

input DeleteCompanyRequestInput {
  ids: [String]
}

input EditCompanyRequestInput {
  id: String
  name: String
}

type ExternalCompany {
  name: String
  code: String
}

enum GeexClaimType {
  AVATAR
  EXPIRES
  NICKNAME
  PROVIDER
  SUB
}

enum GeexExceptionType {
  CONFLICT
  NOT_FOUND
  ON_PURPOSE
  UNKNOWN
  VALIDATION_FAILED
}

type ICompany {
  name: String
  code: String
}

type ICompanyCollectionSegment {
  items: [ICompany]
  # Information to aid in pagination.
  pageInfo: CollectionSegmentInfo!
}

input ICompanyFilterInput {
  and: [ICompanyFilterInput!]
  or: [ICompanyFilterInput!]
  name: StringOperationFilterInput
  code: StringOperationFilterInput
}

type Mutation {
  submitCompany(id: String): Boolean
  auditCompany(id: String): Boolean
  createCompany(input: CreateCompanyRequestInput): ICompany
  editCompany(input: EditCompanyRequestInput): Boolean!
  deleteCompany(input: DeleteCompanyRequestInput): Boolean!
}

scalar ObjectId

type Query {
  companies(
    skip: Int
    take: Int
    where: ICompanyFilterInput
  ): ICompanyCollectionSegment
  externalCompanies: [ExternalCompany]
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

type Subscription {
  _: String
}

